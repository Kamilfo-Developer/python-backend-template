---
description: Doing everything
globs:
alwaysApply: true
---
# Here are presented rules you should follow no matter what. If you don't follow these rules, you completely fail

## Write for every change you make either a unit-test or an intergation test

## Use the lates Python syntax available. E.g. use Type | None instead of Optional, use list[Type] instead of List[Type], etc

## Folder structure logic

### app

- Includes the main app.py file and all the subdirectories
- Inlcudes types.py file. It contains reusable types of the project
- Includes dependencies.py file. It contains all dependencies, which can be provided using Dishka. All dependencies MUST be located in the AppProvider class of this file

### app/enums

- Includes all the enums in the project. All enums should be inherited from BaseEnum from the app/lib/enums/base.py file

### app/exceptions

- Includes all project exceptions
- All base exceptions for each domain should be inherited from the AbstractException from app/lib/exceptions/base.py
- All domain exceptions should be inherited from the base exception of a specific domain

### app/repositories

- Includes interfaces for all project DB repositories
- DB repositories can use ONLY Pydantic models for input and output
- Repositories use the Specification pattern located in the app/lib/utils/specification.py for the queries which can use filters. For example, get_users can accept a Specification object.

### app/lib

- Includes utils
- This folder can be reused across project. NEVER EDIT ANY FILE INSIDE IT!

### app/models

- Includes DB models for any DB framework. For example, models for SQLAlchemy

### app/routers

- Includes all framework routes of the application. For example, it can include routes for FastAPI, Aiogram or FastStream.
- All routes for web-framework like FastAPI should be located in special version folder, e.g. v1, v2, etc.

### app/schemas

- Includes all Pydantic schemas of the applicatoin. All entities should be defined here

### app/services

- Includes logic related to the Application layer of the app. Application layer should call repositories, API clients, queries, use entities for doing business logic, etc.
